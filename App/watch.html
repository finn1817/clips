<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Watch Game Footage - Timon HS Soccer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            height: 100%;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0f0f0f;
            color: white;
            overflow: hidden; /* Prevent page scroll; we'll scroll inside sections */
        }

        .navbar {
            background: #202020;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.5);
        }

        .navbar-brand {
            font-size: 20px;
            font-weight: 600;
            color: #fff;
        }

        .navbar-brand span {
            color: #3ea6ff;
        }

        .brand-logo {
            height: 26px;
            width: 26px;
            object-fit: cover;
            border-radius: 4px;
            vertical-align: middle;
            margin-right: 8px;
        }

        .navbar-actions {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .navbar-btn {
            padding: 8px 16px;
            background: #3ea6ff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .navbar-btn:hover {
            background: #1c8fe0;
        }

        .navbar-btn.secondary {
            background: #2a2a2a;
        }

        .navbar-btn.secondary:hover {
            background: #3a3a3a;
        }

        .main-container {
            display: flex;
            max-width: 1800px;
            height: calc(100vh - 72px); /* Fill viewport minus navbar */
            margin: 10px auto 0;
            padding: 0 20px 10px;
            gap: 20px;
            overflow: hidden; /* Contain inner scrolls */
        }

        .video-section {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            height: 100%;
            min-height: 0; /* allow children to shrink */
        }

        .video-container {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 12px;
            aspect-ratio: 16 / 9;
            max-height: 62vh; /* keep reasonable room for description/controls */
        }

        #videoPlayer {
            width: 100%;
            height: 100%;
            display: block;
            object-fit: contain;
        }

        #drawingCanvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            display: none;
        }

        .video-info {
            background: #202020;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 10px;
            flex: 1 1 0;
            min-height: 0;
            overflow: auto; /* Scroll only the description/pins area */
        }

        .video-title {
            font-size: 20px;
            font-weight: 600;
            margin-bottom: 10px;
        }

        .video-description {
            color: #aaa;
            font-size: 14px;
            line-height: 1.6;
        }

        .admin-controls {
            background: #202020;
            padding: 12px 15px;
            border-radius: 8px;
            display: none;
            margin-bottom: 0;
            flex: 0 0 auto; /* fixed footer-like row under scroller */
        }

        .admin-controls.visible {
            display: block;
        }

        .control-row {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-btn {
            padding: 10px 20px;
            background: #3ea6ff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
        }

        .control-btn:hover {
            background: #1c8fe0;
        }

        .control-btn.danger {
            background: #ff4444;
        }

        .control-btn.danger:hover {
            background: #cc0000;
        }

        .control-btn.active {
            background: #ff9800;
        }

        .drawing-tools {
            display: none;
            gap: 10px;
            align-items: center;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #3a3a3a;
        }

        .drawing-tools.visible {
            display: flex;
        }

        .color-picker {
            width: 50px;
            height: 35px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .tool-btn {
            padding: 8px 16px;
            background: #2a2a2a;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        .tool-btn:hover {
            background: #3a3a3a;
        }

        .tool-btn.active {
            background: #3ea6ff;
        }

        .sidebar {
            width: 400px;
            background: #202020;
            border-radius: 8px;
            padding: 20px;
            height: 100%;
            overflow-y: auto; /* Scroll only video list */
        }

        .sidebar h2 {
            font-size: 18px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid #3a3a3a;
        }

        .video-list-item {
            background: #2a2a2a;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .video-thumb {
            width: 96px;
            height: 54px;
            border-radius: 4px;
            background: #111;
            object-fit: cover;
            flex: none;
        }

        .video-list-content {
            flex: 1;
            min-width: 0;
        }

        .video-list-item:hover {
            background: #3a3a3a;
            transform: translateX(5px);
        }

        .video-list-item.active {
            background: #3ea6ff;
        }

        .video-list-title {
            font-size: 15px;
            font-weight: 600;
            margin-bottom: 5px;
        }

        .video-list-desc {
            font-size: 13px;
            color: #aaa;
        }

        .delete-video-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 5px 10px;
            background: #ff4444;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            display: none;
        }

        .video-list-item:hover .delete-video-btn {
            display: block;
        }

        .delete-video-btn:hover {
            background: #cc0000;
        }

        .no-videos {
            text-align: center;
            padding: 40px 20px;
            color: #666;
        }

        .user-info {
            color: #aaa;
            font-size: 14px;
        }

        /* Pin overlay */
        #pinOverlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0,0,0,0.75);
            border: 1px solid #3a3a3a;
            border-radius: 6px;
            padding: 10px 12px;
            max-width: 50%;
            display: none;
            z-index: 5;
            cursor: pointer;
        }

        #pinOverlay .time {
            color: #3ea6ff;
            font-weight: 600;
            margin-right: 8px;
        }

        /* Pins section */
        .pins-section {
            background: #202020;
            padding: 16px;
            border-radius: 8px;
            margin-top: 12px;
        }

        .pins-section h3 {
            font-size: 16px;
            margin-bottom: 10px;
            border-bottom: 1px solid #3a3a3a;
            padding-bottom: 8px;
        }

        .pin-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px 0;
            border-bottom: 1px solid #2a2a2a;
        }

        .pin-item:last-child { border-bottom: none; }

        .pin-time {
            color: #3ea6ff;
            font-weight: 600;
            cursor: pointer;
            flex: none;
        }

        .pin-note { color: #ccc; font-size: 14px; line-height: 1.4; }

        .pin-delete {
            margin-left: auto;
            background: #ff4444;
            border: none;
            color: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            display: none;
        }

        .pin-item.admin .pin-delete { display: inline-block; }

        /* Fullscreen admin controls overlay */
        .fs-admin-controls {
            position: absolute;
            left: 12px;
            right: 12px;
            top: 12px; /* move to top so it doesn't cover native controls */
            display: none; /* shown only for admins + in fullscreen */
            gap: 8px;
            align-items: center;
            justify-content: flex-start;
            background: rgba(0,0,0,0.55);
            border: 1px solid #3a3a3a;
            border-radius: 8px;
            padding: 8px;
            z-index: 8;
            transition: opacity 0.2s ease;
            opacity: 1;
        }

        .fs-admin-controls.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .control-btn.sm { padding: 8px 12px; font-size: 13px; }

        .fs-hint {
            margin-top: 8px;
            color: #9aa0a6;
            font-size: 12px;
        }

        @media (max-width: 1200px) {
            .main-container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                height: 500px;
            }
        }

        @media (max-width: 768px) {
            .navbar {
                flex-direction: column;
                gap: 10px;
            }

            .navbar-actions {
                width: 100%;
                justify-content: center;
            }

            .control-row {
                flex-direction: column;
            }

            .control-btn {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <nav class="navbar">
    <div class="navbar-brand"><img class="brand-logo" src="https://github.com/finn1817/clips/blob/main/assets/Images/Timon.jpg?raw=true" alt="Timon Logo"><span>Timon HS Soccer</span></div>
        <div class="navbar-actions">
            <span class="user-info" id="userInfo">Loading...</span>
            <button class="navbar-btn" id="uploadBtn" style="display: none;">Upload Video</button>
            <button class="navbar-btn secondary" id="membersBtn" style="display: none;">Manage Members</button>
            <button class="navbar-btn secondary" id="logoutBtn">Logout</button>
        </div>
    </nav>

    <div class="main-container">
        <div class="video-section">
            <div class="video-container">
                <video id="videoPlayer" controls>
                    <source src="" type="video/mp4">
                    Your browser does not support the video tag.
                </video>
                <canvas id="drawingCanvas"></canvas>
                <div id="pinOverlay" title="Click to jump to this moment"></div>
                <!-- Admin controls that remain visible in fullscreen -->
                <div id="fsAdminControls" class="fs-admin-controls">
                    <button class="control-btn sm" id="fsEditModeBtn">‚úèÔ∏è Enable Drawing Mode</button>
                    <button class="control-btn sm" id="fsDownloadBtn">‚¨áÔ∏è Download Video</button>
                    <button class="control-btn sm" id="fsPinHereBtn">üìç Pin Here</button>
                    <button class="control-btn sm" id="fsSetThumbBtn">üñºÔ∏è Set Thumbnail</button>
                    <button class="control-btn sm" id="fsFullscreenToggle" title="Toggle Fullscreen">‚õ∂ Fullscreen</button>
                </div>
            </div>

            <div class="video-info" id="videoInfo">
                <div class="video-title">Select a video to watch</div>
                <div class="video-description">Choose a game from the list on the right</div>
            </div>

            <div class="admin-controls" id="adminControls">
                <div class="control-row">
                    <button class="control-btn" id="editModeBtn">‚úèÔ∏è Enable Drawing Mode</button>
                    <button class="control-btn" id="downloadBtn">‚¨áÔ∏è Download Video</button>
                    <button class="control-btn" id="pinHereBtn">üìç Pin Here</button>
                    <button class="control-btn" id="setThumbBtn">üñºÔ∏è Set Thumbnail</button>
                </div>
                <div class="drawing-tools" id="drawingTools">
                    <span style="font-size: 14px; color: #aaa;">Drawing Tools:</span>
                    <button class="tool-btn active" id="penTool">‚úèÔ∏è Pen</button>
                    <button class="tool-btn" id="circleTool">‚≠ï Circle</button>
                    <button class="tool-btn" id="eraserTool">üßπ Eraser</button>
                    <input type="color" class="color-picker" id="colorPicker" value="#ff0000">
                    <button class="control-btn danger" id="clearCanvas">Clear All</button>
                    <button class="control-btn" id="exitDrawingBtn">Exit Drawing Mode</button>
                </div>
                <div class="fs-hint">Tip: Press <strong>F</strong> on your keyboard to toggle fullscreen when editing.</div>
            </div>
        </div>

        <div class="sidebar">
            <h2>Game Footage</h2>
            <div id="videoList">
                <div class="no-videos">Loading videos...</div>
            </div>
        </div>
    </div>

    <script type="module">
    import { collection, getDocs, doc, getDoc, deleteDoc, addDoc, updateDoc } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-firestore.js";
    import { getStorage, ref, deleteObject, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/12.5.0/firebase-storage.js";
    import { app, db, validateSessionAndGetUser, attachLogout } from "../js/auth.js";

        const firebaseConfig = {
            apiKey: "AIzaSyCBYCj-gsiuAZSnRINPrSsxUWjx6IscSwI",
            authDomain: "soccer-footage.firebaseapp.com",
            projectId: "soccer-footage",
            storageBucket: "soccer-footage.firebasestorage.app",
            messagingSenderId: "571193015931",
            appId: "1:571193015931:web:bfb7732e2a40609408acde"
        };

    const storage = getStorage(app);

    let currentUser = null;
    let isAdmin = false;
    let currentVideoId = null;
    let currentVideoData = null;
    let currentVideoPins = [];
    let lastOverlayTimeout = null;
    let recentlyShownPinIds = new Set();

        // Drawing variables
        let isDrawing = false;
        let drawingMode = false;
        let currentTool = 'pen';
        let currentColor = '#ff0000';
        let lastX = 0;
        let lastY = 0;
        let startX = 0;
        let startY = 0;

        const videoPlayer = document.getElementById('videoPlayer');
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');

        // Session-based auth via shared helper
        (async function checkSession() {
            const { user, data } = await validateSessionAndGetUser({ requireAdmin: false, redirectTo: '../index.html' });
            currentUser = user;
            isAdmin = !!data.isAdmin;
            document.getElementById('userInfo').textContent = `Welcome, ${data.displayName}`;
            if (isAdmin) {
                document.getElementById('uploadBtn').style.display = 'block';
                document.getElementById('membersBtn').style.display = 'block';
                document.getElementById('adminControls').classList.add('visible');
                // Show the fullscreen overlay container (visibility toggled by fullscreen state)
                document.getElementById('fsAdminControls').style.display = 'flex';
            }
            loadVideos();
        })().catch(() => {});

        // Logout
        attachLogout('#logoutBtn', '../index.html');

        // Navigation
        document.getElementById('uploadBtn').addEventListener('click', () => {
            window.location.href = 'upload.html';
        });

        document.getElementById('membersBtn').addEventListener('click', () => {
            window.location.href = 'members.html';
        });

        // Load videos
        async function loadVideos() {
            const videoList = document.getElementById('videoList');
            
            try {
                const videosSnapshot = await getDocs(collection(db, 'videos'));
                
                if (videosSnapshot.empty) {
                    videoList.innerHTML = '<div class="no-videos">No videos uploaded yet.<br>Admins can upload videos using the Upload button.</div>';
                    return;
                }

                videoList.innerHTML = '';
                videosSnapshot.forEach((docSnap) => {
                    const video = docSnap.data();
                    const videoItem = document.createElement('div');
                    videoItem.className = 'video-list-item';
                    const thumbHTML = video.thumbnailURL ? `<img class="video-thumb" src="${video.thumbnailURL}" alt="thumb">` : `<div class="video-thumb"></div>`;
                    videoItem.innerHTML = `
                        ${thumbHTML}
                        <div class="video-list-content">
                            <div class="video-list-title">${video.title}</div>
                            <div class="video-list-desc">${video.description || 'No description'}</div>
                        </div>
                        ${isAdmin ? `<button class="delete-video-btn" data-id="${docSnap.id}">Delete</button>` : ''}
                    `;
                    
                    videoItem.addEventListener('click', (e) => {
                        if (!e.target.classList.contains('delete-video-btn')) {
                            loadVideo(docSnap.id, video);
                        }
                    });

                    if (isAdmin) {
                        const deleteBtn = videoItem.querySelector('.delete-video-btn');
                        deleteBtn.addEventListener('click', async (e) => {
                            e.stopPropagation();
                            if (confirm(`Delete "${video.title}"?`)) {
                                await deleteVideo(docSnap.id, video.storagePath);
                            }
                        });
                    }

                    videoList.appendChild(videoItem);
                });
            } catch (error) {
                console.error('Error loading videos:', error);
                videoList.innerHTML = '<div class="no-videos">Error loading videos</div>';
            }
        }

        // Load video
        function loadVideo(videoId, videoData) {
            currentVideoId = videoId;
            currentVideoData = videoData;
            currentVideoPins = [];
            recentlyShownPinIds.clear();

            // Update active state
            document.querySelectorAll('.video-list-item').forEach(item => {
                item.classList.remove('active');
            });
            event.currentTarget.classList.add('active');

            // Set video source
            videoPlayer.src = videoData.downloadURL;
            videoPlayer.load();

            // Update info
            document.getElementById('videoInfo').innerHTML = `
                <div class="video-title">${videoData.title}</div>
                <div class="video-description">${videoData.description || 'No description'}</div>
            `;

            // Render pins section shell
            renderPinsSection([]);

            // Fetch pins for this video
            loadPinsForVideo(videoId);

            // Reset canvas
            if (drawingMode) {
                exitDrawingMode();
            }
        }

        async function loadPinsForVideo(videoId) {
            try {
                const pinsSnap = await getDocs(collection(db, 'videos', videoId, 'pins'));
                const arr = [];
                pinsSnap.forEach((p) => {
                    const d = p.data();
                    arr.push({ id: p.id, ...d });
                });
                arr.sort((a,b) => (a.timeSec||0) - (b.timeSec||0));
                currentVideoPins = arr;
                renderPinsSection(arr);
            } catch (e) {
                console.error('Error loading pins:', e);
            }
        }

        function renderPinsSection(pins) {
            const container = document.getElementById('videoInfo');
            let section = document.getElementById('pinsSection');
            if (!section) {
                section = document.createElement('div');
                section.id = 'pinsSection';
                section.className = 'pins-section';
                container.appendChild(section);
            }
            if (!pins || pins.length === 0) {
                section.innerHTML = '<h3>Pinned Points</h3><div style="color:#666;font-size:14px;">No pins yet.</div>';
                return;
            }
            const html = ['<h3>Pinned Points</h3>'];
            pins.forEach(pin => {
                const adminClass = isAdmin ? ' admin' : '';
                html.push(`
                    <div class="pin-item${adminClass}">
                        <span class="pin-time" data-pin-id="${pin.id}">${formatTime(pin.timeSec)}</span>
                        <span class="pin-note">${escapeHtml(pin.note || '')}</span>
                        ${isAdmin ? `<button class="pin-delete" data-pin-id="${pin.id}">Delete</button>` : ''}
                    </div>
                `);
            });
            section.innerHTML = html.join('');

            // Bind pin time click
            section.querySelectorAll('.pin-time').forEach(el => {
                el.addEventListener('click', (e) => {
                    const id = e.target.getAttribute('data-pin-id');
                    const pin = currentVideoPins.find(p => p.id === id);
                    if (pin) {
                        videoPlayer.currentTime = Math.max(0, pin.timeSec - 0.05);
                        videoPlayer.play();
                    }
                });
            });

            // Bind delete
            if (isAdmin) {
                section.querySelectorAll('.pin-delete').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const id = e.target.getAttribute('data-pin-id');
                        if (confirm('Delete this pin?')) {
                            try {
                                await deleteDoc(doc(db, 'videos', currentVideoId, 'pins', id));
                                currentVideoPins = currentVideoPins.filter(p => p.id !== id);
                                renderPinsSection(currentVideoPins);
                            } catch (err) {
                                console.error('Error deleting pin:', err);
                                alert('Could not delete pin: ' + (err.message || 'unknown'));
                            }
                        }
                    });
                });
            }
        }

        function formatTime(sec) {
            sec = Math.max(0, Math.floor(sec || 0));
            const m = Math.floor(sec / 60);
            const s = sec % 60;
            return `${m}:${s.toString().padStart(2,'0')}`;
        }

        function escapeHtml(s) {
            return (s||'').replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
        }

        // Delete video
        async function deleteVideo(videoId, storagePath) {
            try {
                // Delete from Storage
                const storageRef = ref(storage, storagePath);
                await deleteObject(storageRef);

                // Delete from Firestore
                await deleteDoc(doc(db, 'videos', videoId));

                alert('Video deleted successfully');
                loadVideos();

                if (currentVideoId === videoId) {
                    videoPlayer.src = '';
                    document.getElementById('videoInfo').innerHTML = `
                        <div class="video-title">Select a video to watch</div>
                        <div class="video-description">Choose a game from the list on the right</div>
                    `;
                }
            } catch (error) {
                console.error('Error deleting video:', error);
                alert('Error deleting video: ' + error.message);
            }
        }

        // Download video
        document.getElementById('downloadBtn').addEventListener('click', () => {
            if (!currentVideoData) {
                alert('Please select a video first');
                return;
            }

            const a = document.createElement('a');
            a.href = currentVideoData.downloadURL;
            a.download = currentVideoData.fileName;
            a.click();
        });

        // Mirror actions to fullscreen overlay buttons
        const mirror = (srcId, destId) => {
            const src = document.getElementById(srcId);
            const dest = document.getElementById(destId);
            if (src && dest) dest.addEventListener('click', () => src.click());
        };
        mirror('editModeBtn','fsEditModeBtn');
        mirror('downloadBtn','fsDownloadBtn');
        mirror('pinHereBtn','fsPinHereBtn');
        mirror('setThumbBtn','fsSetThumbBtn');

        // Pin Here (admin)
        document.getElementById('pinHereBtn').addEventListener('click', async () => {
            if (!isAdmin || !currentVideoData) {
                alert('Select a video first');
                return;
            }
            const timeSec = videoPlayer.currentTime;
            let note = prompt('Add a short note for this pin (max 500 chars):') || '';
            if (note.length > 500) note = note.slice(0, 500);
            try {
                const userDoc = await getDoc(doc(db, 'users', currentUser.uid));
                const userData = userDoc.data() || {};
                const newPin = {
                    timeSec: Math.round(timeSec * 10) / 10,
                    note,
                    createdBy: currentUser.uid,
                    createdByName: userData.displayName || 'Unknown',
                    createdAt: new Date()
                };
                const added = await addDoc(collection(db, 'videos', currentVideoId, 'pins'), newPin);
                currentVideoPins.push({ id: added.id, ...newPin });
                currentVideoPins.sort((a,b) => (a.timeSec||0) - (b.timeSec||0));
                renderPinsSection(currentVideoPins);
                // Show overlay immediately
                showPinOverlay({ id: added.id, ...newPin });
            } catch (err) {
                console.error('Error adding pin:', err);
                alert('Could not add pin: ' + (err.message || 'unknown'));
            }
        });

        // Set Thumbnail (admin)
        document.getElementById('setThumbBtn').addEventListener('click', async () => {
            if (!isAdmin || !currentVideoData) {
                alert('Select a video first');
                return;
            }
            try {
                const blob = await captureFrame(videoPlayer);
                if (!blob) {
                    alert('Could not capture frame. If this persists, your Storage bucket may need CORS enabled.');
                    return;
                }
                const thumbPath = `thumbnails/${currentVideoId}.jpg`;
                const storageRef = ref(storage, thumbPath);
                await uploadBytes(storageRef, blob, { contentType: 'image/jpeg' });
                const url = await getDownloadURL(storageRef);
                await updateVideoDoc({ thumbnailURL: url, thumbnailPath: thumbPath, thumbnailUpdatedAt: new Date() });
                // Update currentVideoData and list UI casually
                currentVideoData.thumbnailURL = url;
                // Refresh list for current visual update (optional: minimal patch)
                loadVideos();
                alert('Thumbnail set successfully');
            } catch (err) {
                console.error('Error setting thumbnail:', err);
                alert('Could not set thumbnail: ' + (err.message || 'unknown'));
            }
        });

        async function updateVideoDoc(patch) {
            try {
                const docRef = doc(db, 'videos', currentVideoId);
                await updateDoc(docRef, patch);
            } catch (e) {
                console.error('updateVideoDoc failed', e);
                throw e;
            }
        }

        // Drawing mode
        document.getElementById('editModeBtn').addEventListener('click', () => {
            if (!currentVideoData) {
                alert('Please select a video first');
                return;
            }
            enterDrawingMode();
        });

        document.getElementById('exitDrawingBtn').addEventListener('click', () => {
            exitDrawingMode();
        });

        function enterDrawingMode() {
            drawingMode = true;
            videoPlayer.pause();
            
            // Setup canvas
            canvas.width = videoPlayer.offsetWidth;
            canvas.height = videoPlayer.offsetHeight;
            canvas.style.display = 'block';

            document.getElementById('drawingTools').classList.add('visible');
            document.getElementById('editModeBtn').classList.add('active');
            document.getElementById('editModeBtn').textContent = 'üé® Drawing Mode Active';
        }

        function exitDrawingMode() {
            drawingMode = false;
            canvas.style.display = 'none';
            document.getElementById('drawingTools').classList.remove('visible');
            document.getElementById('editModeBtn').classList.remove('active');
            document.getElementById('editModeBtn').textContent = '‚úèÔ∏è Enable Drawing Mode';
        }

        // Drawing tools
        document.getElementById('penTool').addEventListener('click', () => {
            selectTool('pen');
        });

        document.getElementById('circleTool').addEventListener('click', () => {
            selectTool('circle');
        });

        document.getElementById('eraserTool').addEventListener('click', () => {
            selectTool('eraser');
        });

        document.getElementById('colorPicker').addEventListener('change', (e) => {
            currentColor = e.target.value;
        });

        document.getElementById('clearCanvas').addEventListener('click', () => {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        });

        function selectTool(tool) {
            currentTool = tool;
            document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
            document.getElementById(tool + 'Tool').classList.add('active');
        }

        // Canvas drawing
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        // Touch support
        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousedown', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            const mouseEvent = new MouseEvent('mousemove', {
                clientX: touch.clientX,
                clientY: touch.clientY
            });
            canvas.dispatchEvent(mouseEvent);
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            const mouseEvent = new MouseEvent('mouseup', {});
            canvas.dispatchEvent(mouseEvent);
        });

        function startDrawing(e) {
            if (!drawingMode) return;
            
            isDrawing = true;
            const rect = canvas.getBoundingClientRect();
            lastX = e.clientX - rect.left;
            lastY = e.clientY - rect.top;
            startX = lastX;
            startY = lastY;
        }

        function draw(e) {
            if (!isDrawing || !drawingMode) return;

            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            ctx.lineWidth = currentTool === 'eraser' ? 20 : 3;
            ctx.lineCap = 'round';
            ctx.strokeStyle = currentTool === 'eraser' ? '#000000' : currentColor;
            ctx.globalCompositeOperation = currentTool === 'eraser' ? 'destination-out' : 'source-over';

            if (currentTool === 'pen' || currentTool === 'eraser') {
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(x, y);
                ctx.stroke();
                lastX = x;
                lastY = y;
            }
        }

        function stopDrawing(e) {
            if (!isDrawing || !drawingMode) return;

            if (currentTool === 'circle') {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const radius = Math.sqrt(Math.pow(x - startX, 2) + Math.pow(y - startY, 2));
                
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = currentColor;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(startX, startY, radius, 0, 2 * Math.PI);
                ctx.stroke();
            }

            isDrawing = false;
        }

        // Resize canvas when window resizes
        window.addEventListener('resize', () => {
            if (drawingMode) {
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                canvas.width = videoPlayer.offsetWidth;
                canvas.height = videoPlayer.offsetHeight;
                ctx.putImageData(imageData, 0, 0);
            }
        });

        // Timeupdate to trigger pin overlay
        videoPlayer.addEventListener('timeupdate', () => {
            if (!currentVideoPins || currentVideoPins.length === 0) return;
            const t = videoPlayer.currentTime;
            // Show pins whose timeSec is within 0.25s of current time, and not shown in the last second
            const near = currentVideoPins.find(p => Math.abs((p.timeSec||0) - t) < 0.25);
            if (near) {
                const key = `${near.id}@${Math.floor(t)}`;
                if (!recentlyShownPinIds.has(key)) {
                    showPinOverlay(near);
                    recentlyShownPinIds.add(key);
                    // Cleanup keys to avoid unlimited growth
                    if (recentlyShownPinIds.size > 1000) {
                        recentlyShownPinIds.clear();
                    }
                }
            }
        });

        function showPinOverlay(pin) {
            const el = document.getElementById('pinOverlay');
            el.innerHTML = `<span class="time">${formatTime(pin.timeSec)}</span>${escapeHtml(pin.note || '')}`;
            el.style.display = 'block';
            el.onclick = () => {
                videoPlayer.currentTime = Math.max(0, (pin.timeSec||0) - 0.05);
                videoPlayer.play();
            };
            if (lastOverlayTimeout) clearTimeout(lastOverlayTimeout);
            lastOverlayTimeout = setTimeout(() => {
                el.style.display = 'none';
            }, 6000);
        }

        async function captureFrame(videoEl) {
            try {
                const w = videoEl.videoWidth || 1280;
                const h = videoEl.videoHeight || 720;
                const c = document.createElement('canvas');
                c.width = Math.max(320, Math.min(960, w));
                c.height = Math.round(c.width * (h / w));
                const cctx = c.getContext('2d');
                cctx.drawImage(videoEl, 0, 0, c.width, c.height);
                return await new Promise(resolve => c.toBlob(resolve, 'image/jpeg', 0.8));
            } catch (e) {
                console.error('captureFrame failed', e);
                return null;
            }
        }

        // Make pin overlay draggable
        (function makeOverlayDraggable(){
            const el = document.getElementById('pinOverlay');
            let dragging = false; let startX=0, startY=0, startLeft=0, startTop=0;
            el.addEventListener('mousedown', (e) => {
                dragging = true;
                // Switch to left/top positioning for drag
                const rect = el.getBoundingClientRect();
                const parentRect = el.parentElement.getBoundingClientRect();
                el.style.left = (rect.left - parentRect.left) + 'px';
                el.style.top = (rect.top - parentRect.top) + 'px';
                el.style.right = 'auto';
                startX = e.clientX; startY = e.clientY;
                startLeft = parseFloat(el.style.left) || 0;
                startTop = parseFloat(el.style.top) || 0;
                e.preventDefault();
            });
            window.addEventListener('mousemove', (e) => {
                if (!dragging) return;
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                el.style.left = (startLeft + dx) + 'px';
                el.style.top = (startTop + dy) + 'px';
            });
            window.addEventListener('mouseup', () => { dragging = false; });
        })();

        // Fullscreen helpers for overlay visibility and toggle
        const fsControls = document.getElementById('fsAdminControls');
        const videoContainer = document.querySelector('.video-container');
        let fsHideTimer = null;

        function isFullScreen() {
            return !!document.fullscreenElement;
        }

        function updateFsControlsVisibility() {
            if (!isAdmin) return;
            // Only show overlay while the CONTAINER is fullscreen
            if (document.fullscreenElement === videoContainer) {
                fsControls.classList.remove('hidden');
                // Start auto-hide timer
                showFsControlsTemporarily();
            } else {
                fsControls.classList.add('hidden');
            }
        }

        function showFsControlsTemporarily() {
            if (!isAdmin || !isFullScreen()) return;
            fsControls.classList.remove('hidden');
            clearTimeout(fsHideTimer);
            fsHideTimer = setTimeout(() => fsControls.classList.add('hidden'), 2500);
        }

        document.addEventListener('fullscreenchange', () => {
            updateFsControlsVisibility();
        });
        videoContainer.addEventListener('mousemove', showFsControlsTemporarily);

        // Fullscreen toggle requests fullscreen for the container so overlay is included
        async function toggleContainerFullscreen() {
            try {
                if (document.fullscreenElement === videoContainer) {
                    await document.exitFullscreen();
                } else {
                    if (videoContainer.requestFullscreen) await videoContainer.requestFullscreen();
                }
            } catch (e) { console.warn('fullscreen toggle failed', e); }
        }

        document.getElementById('fsFullscreenToggle').addEventListener('click', toggleContainerFullscreen);

        // Also allow double-click on the video container and pressing 'f' to toggle container fullscreen
        videoContainer.addEventListener('dblclick', toggleContainerFullscreen);
        document.addEventListener('keydown', (e) => {
            if ((e.key === 'f' || e.key === 'F') && document.activeElement) {
                // treat as user gesture
                toggleContainerFullscreen();
            }
        });
    </script>
</body>
</html>